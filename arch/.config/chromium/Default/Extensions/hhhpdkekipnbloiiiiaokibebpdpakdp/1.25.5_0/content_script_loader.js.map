{"version":3,"sources":["webpack:///webpack/bootstrap d4f904c6770962e59cd8","webpack:///./src/client/interceptedEventTypes.js","webpack:///./src/lib/dom.js","webpack:///./src/content_script/eventListeners.js","webpack:///./src/content_script/loader.js","webpack:///./node_modules/mosi/light-client.js"],"names":["element","root","activeElement","activeElementShadowRoot","events","type","event","view","detail","textArea","document","value","url","JSON","saveAs","fullscreenchange","window","Object","eventType","addPreloadedEventListeners","msg"],"mappings":"aAIA,cAGA,QACA,oBAGA,YACA,GADA,CAEA,IAFA,CAGA,UAHA,EAaA,MANA,mCAMA,CAHA,MAGA,UACA,CAxBA,SA4DA,MAhCA,MAgCA,CA7BA,KA6BA,CA1BA,oBACA,QADA,EAEA,2BACA,eADA,CAEA,aAFA,CAGA,KAHA,EAMA,CAkBA,CAfA,gBACA,sBACA,WAA2B,mBAA4B,CADvD,CAEA,WAAiC,QAAe,CAFhD,CAIA,MADA,aACA,EACA,CASA,CANA,kBAAsD,gDAA+D,CAMrH,CAHA,MAGA,U,oCC7DA,WAMe,4EAQb,QARa,C,+BCyBf,aAAuC,CACrC,GAAIA,YAAoBA,EAAxB,SAA0C,SAC1C,OAAQA,EAAR,MACE,YACA,WACA,aACA,YACA,UACA,aACA,eACA,WACA,UACE,SAVJ,CAYA,QACD,CAQM,WAA4BC,EAA5B,SAA6C,CAClD,KAAMC,GAAgBD,EAAtB,cACME,EAA0BD,GAAiBA,EAAjD,UADA,CAEA,MAAOC,GAAP,IAAOA,EAGR,C,IAnDM,WAAkC,CACvC,KAAa,CACX,OAAQH,EAAR,UACE,YACE,YACF,eACA,aACE,SALJ,CAOA,WACE,UAAKA,kCAAL,CACA,iBAAKA,SAAL,CACE,SAHJ,CAKD,CACD,QACD,C,WA4CM,kBAAuD,CAC5D,MAEE,OAH0D,KAIxDI,wCAJwD,CAM1D,SAN0D,KAOxDA,uCAPwD,CAS1D,OAT0D,KAUxDA,6CAVwD,QAa5DA,UAAeC,KAAQ,CACrB,KAAMC,GAAQ,6CAGZC,KAHY,OAIZC,OAJF,CAAc,KAAd,CAOAR,kBARFI,EAUD,C,KAgBM,WAAmC,cAGpC,kBAHoC,EAOzC,C,KA2BM,WAAqB,CAC1B,KAAMK,GAAWC,uBAAjB,UAAiBA,CAAjB,CACAD,gCAF0B,CAG1BA,SAH0B,CAI1BC,4BAJ0B,CAK1BD,UAL0B,CAM1BC,4BAN0B,CAO1BA,4BACD,C,KAQM,UAAkB,CACvB,KAAMD,GAAWC,uBAAjB,UAAiBA,CAAjB,CACAD,gCAFuB,CAGvBC,4BAHuB,CAIvBD,SAJuB,CAKvBC,6BALuB,CAMvB,KAAMC,GAAQF,EAAd,MAEA,MADAC,6BACA,EACD,C,KAGM,mBAA+C,CACpD,KAAME,GAAM,oBACV,SAAS,CAACC,sBAAV,CAAUA,CAAD,CAAT,CAA4C,CAC1CR,KAAM,qCADoC,CAA5C,CADU,CAAZ,CAKA,KAAM,4BAA2B,kBAG/BS,SAH+B,CAA3B,C,uKA/ED,KAAMC,GAAN,8B,kCChFP,aAAiC,CAC/BC,wBACD,C,6DCLGA,qBAAJ,CAA6BA,mB,GDOtB,UAAuC,CAC5CA,sBAAwB,IAAM,CAA9BA,CAD4C,CAE5CC,yBAA2C,KAAkB,CAC3DD,+BADFC,EAF4C,CAK5CD,uCAAyC,IAAM,CAC7CA,sBAAwB,IAAM,CAA9BA,CAD6C,CAE7CC,yBAA2CC,KAAa,CACtDF,kCADFC,EAF6C,GAA/CD,CAL4C,G,CCN5CG,E,CACAC,CCJK,UACP,SACA,iDAEA,4BACA,aADA,CAEA,KAFA,CAGA,QAHA,CAIA,KAJA,EAMA,CDNEA,iB","file":"content_script_loader.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 39);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d4f904c6770962e59cd8","import { fullscreenchange } from 'lib/dom'\n\n/**\n * Events Saka Key intercepts and whether they must be trusted or not.\n * Keyboard events must be trusted so that websites cannot issue arbitrary commands\n */\nexport default {\n  keydown: true,\n  keypress: true,\n  keyup: true,\n  blur: false,\n  focus: false,\n  click: false,\n  mousedown: false,\n  [fullscreenchange]: false\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/interceptedEventTypes.js","/**\n * Given a DOM element, returns true if you can edit it with key presses or\n * if the element is of a type that should handle its own keypresses\n * (e.g. role=application for google docs/sheets)\n * TODO: work on case sensitivity\n * consider all the possible cases\n * @param {HTMLElement} element\n * @returns {boolean}\n */\nexport function isTextEditable (element) {\n  if (element) {\n    switch (element.nodeName) {\n      case 'INPUT':\n        return isEditableHTMLInput(element)\n      case 'TEXTAREA':\n      case 'OBJECT':\n        return true\n    }\n    switch (true) {\n      case element.contentEditable.toUpperCase() === 'TRUE':\n      case element.role === 'application':\n        return true\n    }\n  }\n  return false\n}\n\n/**\n * Returns whether the passed HTML input element is editable\n * @param {HTMLInputElement} element\n */\nfunction isEditableHTMLInput (element) {\n  if (element.disabled || element.readonly) return false\n  switch (element.type) {\n    case undefined:\n    case 'text':\n    case 'search':\n    case 'email':\n    case 'url':\n    case 'number':\n    case 'password':\n    case 'date':\n    case 'tel':\n      return true\n  }\n  return false\n}\n\n/**\n * Like document.activeElement, but penetrates through Shadow DOM\n * A good example is: https://web.archive.org/web/20170621214451/https://material.io/icons/\n * Click on the input. document.activeElement is different from deepActiveElement()\n * @param {HTMLElement} root\n */\nexport function deepActiveElement (root = document) {\n  const activeElement = root.activeElement\n  const activeElementShadowRoot = activeElement && activeElement.shadowRoot\n  return activeElementShadowRoot\n    ? deepActiveElement(activeElementShadowRoot)\n    : activeElement\n}\n\n/**\n * Dispatch a mouse event to the target element\n * based on cVim's implementation\n * @param {HTMLElement} element\n * @param {'hover' | 'unhover' | 'click'} type\n * @param {{ ctrlKey, shiftKey, altKey, metaKey }} modifierKeys\n */\nexport function mouseEvent (element, type, modifierKeys = {}) {\n  let events\n  switch (type) {\n    case 'hover':\n      events = ['mouseover', 'mouseenter', 'mousemove']\n      break\n    case 'unhover':\n      events = ['mousemove', 'mouseout', 'mouseleave']\n      break\n    case 'click':\n      events = ['mouseover', 'mousedown', 'mouseup', 'click']\n      break\n  }\n  events.forEach(type => {\n    const event = new MouseEvent(type, {\n      bubbles: true,\n      cancelable: true,\n      view: window,\n      detail: 1, // usually the click count\n      ...modifierKeys\n    })\n    element.dispatchEvent(event)\n  })\n}\n\n/**\n * TODO: use standard fullscreenchange event when browsers support it\n */\nexport const fullscreenchange =\n  SAKA_PLATFORM === 'chrome'\n    ? 'webkitfullscreenchange'\n    : SAKA_PLATFORM === 'firefox' ? 'mozfullscreenchange' : 'fullscreenchange'\n/**\n * Given a DOM event type that is vendor pre-fixed, e.g. 'mozfullscreenchange',\n * converts it to a standardized event type, e.g. 'fullscreenchange'\n * TODO: remove this if no vendor-prefixed events are needed\n * @param {string} event\n * @returns {string}\n */\nexport function normalizeEventType (type) {\n  switch (type) {\n    case fullscreenchange:\n      return 'fullscreenchange'\n    default:\n      return type\n  }\n}\n\n// TODO: figure out why elements within shadow roots aren't registered as\n// visible/clickable, then start using this method\n/**\n * Given an HTML Element, returns a list of all elements within\n * penetrating the shadow DOM\n * @param {HTMLElement} root\n */\nexport function getAllElementsIncludingShadowDOM (root = document) {\n  const allElements = root.querySelectorAll('*')\n  let shadowDescendents = []\n  allElements.forEach(element => {\n    if (element.shadowRoot) {\n      shadowDescendents = [\n        ...shadowDescendents,\n        ...getAllElementsIncludingShadowDOM(element.shadowRoot)\n      ]\n    }\n  })\n  return [...allElements, shadowDescendents]\n}\n\n/**\n * Copies the specified text to the clipboard\n * @param {string} text\n */\nexport function copy (text) {\n  const textArea = document.createElement('textarea')\n  textArea.style = 'position:fixed;right:0'\n  textArea.value = text\n  document.body.appendChild(textArea)\n  textArea.select()\n  document.execCommand('Copy')\n  document.body.removeChild(textArea)\n}\n\n/**\n * Returns the clipboard contents.\n * This method is only callable from the background page and requires\n * the \"clipboardRead\" permission to be declared in manifest.json\n * @returns {string}\n */\nexport function paste () {\n  const textArea = document.createElement('textarea')\n  textArea.style = 'position:fixed;right:0'\n  document.body.appendChild(textArea)\n  textArea.focus()\n  document.execCommand('Paste')\n  const value = textArea.value\n  document.body.removeChild(textArea)\n  return value\n}\n\n/** Saves the given object to a human-readable JSON file */\nexport async function downloadJSON (object, filename) {\n  const url = URL.createObjectURL(\n    new Blob([JSON.stringify(object, null, 2)], {\n      type: 'data:application/json;charset=utf-8'\n    })\n  )\n  await browser.downloads.download({\n    url,\n    filename,\n    saveAs: true\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/dom.js","// Saka Key installs exactly one listener for each event type of interest.\n//\n// These listeners must be installed as soon as possible, otherwise the\n// page may intercept and respond to events before Saka Key can.\n//\n// To accomplish this, the _loader script_ installs listeners that call\n// window.handleDOMEvent. When the _full client_ loads, it then defines\n// window.handleDOMEvent\n//\n// When an extension updates, Chrome cuts off content scripts from the\n// rest of the extension. This breaks messaging, so commands that rely on\n// messaging will silently stop working. To work around this, the client\n// detects when messaging is cut off and removes its event listeners. The\n// background page then loads in new clients that can handle events without\n// interference from old event listeners.\nimport interceptedEventTypes from 'client/interceptedEventTypes'\n\nfunction _handleDOMEvent (event) {\n  window.handleDOMEvent(event)\n}\n\nexport function addPreloadedEventListeners () {\n  window.handleDOMEvent = () => {}\n  Object.keys(interceptedEventTypes).forEach((eventType, i) => {\n    window.addEventListener(eventType, _handleDOMEvent, true)\n  })\n  window.removePreloadedDOMEventListener = () => {\n    window.handleDOMEvent = () => {}\n    Object.keys(interceptedEventTypes).forEach(eventType => {\n      window.removeEventListener(eventType, _handleDOMEvent, true)\n    })\n    if (SAKA_DEBUG) console.log('Preloaded Event Listeners Removed')\n  }\n  if (SAKA_DEBUG) console.log('Preloaded Event Listeners Added')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/content_script/eventListeners.js","/**\n * On Firefox, this script is unused and the full client is loaded into every frame.\n * On Chrome, this script is loaded into every frame of every page.\n * \n * The full Saka Key client (at ./index.js) is loaded only into frames\n * that the user can actually interact with to improve performance\n * \n * DOM event listeners must be installed AS SOON AS POSSIBLE otherwise\n * webpages may install listeners that react to keyboard events before Saka Key\n */\n\nimport { msg } from 'mosi/light-client'\nimport { addPreloadedEventListeners } from 'content_script/eventListeners'\n\nif (window.innerWidth > 5 && window.innerHeight > 5) {\n  addPreloadedEventListeners()\n  msg(1, 'loadClient')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/content_script/loader.js","/**\n * A lightweight, limited, msg implementation. Light-clients don't support\n * response handling thus the loop back destination (0) is invalid.\n *\n * This function is useful for avoiding code bloat loading the full mosi client\n * into frames that only need to send a simple one-off message for setup.\n *\n * Saka Key (https://github.com/lusakasa/sakakey) loads a small setup script\n * into each frame, and if the frame is determined to be valid, uses this\n * to send a message to the background page, which loads the full Saka Key\n * content script using chrome.tabs.executeScript.\n */\nexport const msg = (dst, action, arg) => {\n  if (dst === 0) {\n    throw Error('light-client msg self unsupported');\n  }\n  chrome.runtime.sendMessage({\n    mosi_lw_msg: 1,\n    dst,\n    action,\n    arg\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/mosi/light-client.js\n// module id = null\n// module chunks = "],"sourceRoot":""}